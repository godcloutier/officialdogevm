// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SMARTDOGE_SMARTDOGE_H_
#define FLATBUFFERS_GENERATED_SMARTDOGE_SMARTDOGE_H_

#include "flatbuffers/flatbuffers.h"

namespace SmartDoge {

struct RawProtocol;
struct RawProtocolBuilder;

struct IpfsData;
struct IpfsDataBuilder;

struct FileKey;
struct FileKeyBuilder;

struct StoreResponse;
struct StoreResponseBuilder;

struct RetrieveResponse;
struct RetrieveResponseBuilder;

struct ContractRawData;
struct ContractRawDataBuilder;

struct StoreContractResponse;
struct StoreContractResponseBuilder;

struct ContractRequestResponse;
struct ContractRequestResponseBuilder;

struct ContractRequest;
struct ContractRequestBuilder;

enum VersionByte : int8_t {
  VersionByte_Default = 0,
  VersionByte_Segwit = 1,
  VersionByte_SD = 10,
  VersionByte_MIN = VersionByte_Default,
  VersionByte_MAX = VersionByte_SD
};

inline const VersionByte (&EnumValuesVersionByte())[3] {
  static const VersionByte values[] = {
    VersionByte_Default,
    VersionByte_Segwit,
    VersionByte_SD
  };
  return values;
}

inline const char * const *EnumNamesVersionByte() {
  static const char * const names[12] = {
    "Default",
    "Segwit",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "SD",
    nullptr
  };
  return names;
}

inline const char *EnumNameVersionByte(VersionByte e) {
  if (flatbuffers::IsOutRange(e, VersionByte_Default, VersionByte_SD)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesVersionByte()[index];
}

enum ProtocolVersionByte : int8_t {
  ProtocolVersionByte_Default = 0,
  ProtocolVersionByte_NoRoute = 10,
  ProtocolVersionByte_RouteTo = 11,
  ProtocolVersionByte_UseVM = 12,
  ProtocolVersionByte_MIN = ProtocolVersionByte_Default,
  ProtocolVersionByte_MAX = ProtocolVersionByte_UseVM
};

inline const ProtocolVersionByte (&EnumValuesProtocolVersionByte())[4] {
  static const ProtocolVersionByte values[] = {
    ProtocolVersionByte_Default,
    ProtocolVersionByte_NoRoute,
    ProtocolVersionByte_RouteTo,
    ProtocolVersionByte_UseVM
  };
  return values;
}

inline const char * const *EnumNamesProtocolVersionByte() {
  static const char * const names[14] = {
    "Default",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "NoRoute",
    "RouteTo",
    "UseVM",
    nullptr
  };
  return names;
}

inline const char *EnumNameProtocolVersionByte(ProtocolVersionByte e) {
  if (flatbuffers::IsOutRange(e, ProtocolVersionByte_Default, ProtocolVersionByte_UseVM)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesProtocolVersionByte()[index];
}

struct RawProtocol FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RawProtocolBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_PROTOCOL_VERSION = 6,
    VT_OPTIONAL_ROUTING = 8,
    VT_HEX_OPCODES = 10,
    VT_ASM_OPCODES = 12,
    VT_NONCE = 14,
    VT_BYTE_SIZE = 16,
    VT_DATA = 18,
    VT_SIGNATURE = 20
  };
  SmartDoge::VersionByte version() const {
    return static_cast<SmartDoge::VersionByte>(GetField<int8_t>(VT_VERSION, 0));
  }
  SmartDoge::ProtocolVersionByte protocol_version() const {
    return static_cast<SmartDoge::ProtocolVersionByte>(GetField<int8_t>(VT_PROTOCOL_VERSION, 0));
  }
  const flatbuffers::Vector<uint8_t> *optional_routing() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_OPTIONAL_ROUTING);
  }
  const flatbuffers::Vector<uint8_t> *hex_opcodes() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_HEX_OPCODES);
  }
  const flatbuffers::Vector<uint8_t> *asm_opcodes() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ASM_OPCODES);
  }
  uint32_t nonce() const {
    return GetField<uint32_t>(VT_NONCE, 0);
  }
  uint32_t byte_size() const {
    return GetField<uint32_t>(VT_BYTE_SIZE, 0);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  const flatbuffers::Vector<uint8_t> *signature() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_SIGNATURE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_VERSION) &&
           VerifyField<int8_t>(verifier, VT_PROTOCOL_VERSION) &&
           VerifyOffset(verifier, VT_OPTIONAL_ROUTING) &&
           verifier.VerifyVector(optional_routing()) &&
           VerifyOffset(verifier, VT_HEX_OPCODES) &&
           verifier.VerifyVector(hex_opcodes()) &&
           VerifyOffset(verifier, VT_ASM_OPCODES) &&
           verifier.VerifyVector(asm_opcodes()) &&
           VerifyField<uint32_t>(verifier, VT_NONCE) &&
           VerifyField<uint32_t>(verifier, VT_BYTE_SIZE) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           VerifyOffset(verifier, VT_SIGNATURE) &&
           verifier.VerifyVector(signature()) &&
           verifier.EndTable();
  }
};

struct RawProtocolBuilder {
  typedef RawProtocol Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(SmartDoge::VersionByte version) {
    fbb_.AddElement<int8_t>(RawProtocol::VT_VERSION, static_cast<int8_t>(version), 0);
  }
  void add_protocol_version(SmartDoge::ProtocolVersionByte protocol_version) {
    fbb_.AddElement<int8_t>(RawProtocol::VT_PROTOCOL_VERSION, static_cast<int8_t>(protocol_version), 0);
  }
  void add_optional_routing(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> optional_routing) {
    fbb_.AddOffset(RawProtocol::VT_OPTIONAL_ROUTING, optional_routing);
  }
  void add_hex_opcodes(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> hex_opcodes) {
    fbb_.AddOffset(RawProtocol::VT_HEX_OPCODES, hex_opcodes);
  }
  void add_asm_opcodes(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> asm_opcodes) {
    fbb_.AddOffset(RawProtocol::VT_ASM_OPCODES, asm_opcodes);
  }
  void add_nonce(uint32_t nonce) {
    fbb_.AddElement<uint32_t>(RawProtocol::VT_NONCE, nonce, 0);
  }
  void add_byte_size(uint32_t byte_size) {
    fbb_.AddElement<uint32_t>(RawProtocol::VT_BYTE_SIZE, byte_size, 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(RawProtocol::VT_DATA, data);
  }
  void add_signature(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> signature) {
    fbb_.AddOffset(RawProtocol::VT_SIGNATURE, signature);
  }
  explicit RawProtocolBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RawProtocol> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RawProtocol>(end);
    return o;
  }
};

inline flatbuffers::Offset<RawProtocol> CreateRawProtocol(
    flatbuffers::FlatBufferBuilder &_fbb,
    SmartDoge::VersionByte version = SmartDoge::VersionByte_Default,
    SmartDoge::ProtocolVersionByte protocol_version = SmartDoge::ProtocolVersionByte_Default,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> optional_routing = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> hex_opcodes = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> asm_opcodes = 0,
    uint32_t nonce = 0,
    uint32_t byte_size = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> signature = 0) {
  RawProtocolBuilder builder_(_fbb);
  builder_.add_signature(signature);
  builder_.add_data(data);
  builder_.add_byte_size(byte_size);
  builder_.add_nonce(nonce);
  builder_.add_asm_opcodes(asm_opcodes);
  builder_.add_hex_opcodes(hex_opcodes);
  builder_.add_optional_routing(optional_routing);
  builder_.add_protocol_version(protocol_version);
  builder_.add_version(version);
  return builder_.Finish();
}

inline flatbuffers::Offset<RawProtocol> CreateRawProtocolDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    SmartDoge::VersionByte version = SmartDoge::VersionByte_Default,
    SmartDoge::ProtocolVersionByte protocol_version = SmartDoge::ProtocolVersionByte_Default,
    const std::vector<uint8_t> *optional_routing = nullptr,
    const std::vector<uint8_t> *hex_opcodes = nullptr,
    const std::vector<uint8_t> *asm_opcodes = nullptr,
    uint32_t nonce = 0,
    uint32_t byte_size = 0,
    const std::vector<uint8_t> *data = nullptr,
    const std::vector<uint8_t> *signature = nullptr) {
  auto optional_routing__ = optional_routing ? _fbb.CreateVector<uint8_t>(*optional_routing) : 0;
  auto hex_opcodes__ = hex_opcodes ? _fbb.CreateVector<uint8_t>(*hex_opcodes) : 0;
  auto asm_opcodes__ = asm_opcodes ? _fbb.CreateVector<uint8_t>(*asm_opcodes) : 0;
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  auto signature__ = signature ? _fbb.CreateVector<uint8_t>(*signature) : 0;
  return SmartDoge::CreateRawProtocol(
      _fbb,
      version,
      protocol_version,
      optional_routing__,
      hex_opcodes__,
      asm_opcodes__,
      nonce,
      byte_size,
      data__,
      signature__);
}

struct IpfsData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IpfsDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_ENC_TYPE = 6,
    VT_DATA_TYPE = 8,
    VT_LOCKED = 10,
    VT_RECIPIENT = 12,
    VT_OWNER = 14,
    VT_FILE_SIZE = 16,
    VT_ENC_DATA = 18,
    VT_CHECKSUM = 20
  };
  const flatbuffers::Vector<uint8_t> *key() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_KEY);
  }
  const flatbuffers::String *enc_type() const {
    return GetPointer<const flatbuffers::String *>(VT_ENC_TYPE);
  }
  const flatbuffers::String *data_type() const {
    return GetPointer<const flatbuffers::String *>(VT_DATA_TYPE);
  }
  bool locked() const {
    return GetField<uint8_t>(VT_LOCKED, 0) != 0;
  }
  const flatbuffers::Vector<uint8_t> *recipient() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_RECIPIENT);
  }
  const flatbuffers::Vector<uint8_t> *owner() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_OWNER);
  }
  uint32_t file_size() const {
    return GetField<uint32_t>(VT_FILE_SIZE, 0);
  }
  const flatbuffers::Vector<uint8_t> *enc_data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ENC_DATA);
  }
  const flatbuffers::Vector<uint8_t> *checksum() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CHECKSUM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyVector(key()) &&
           VerifyOffset(verifier, VT_ENC_TYPE) &&
           verifier.VerifyString(enc_type()) &&
           VerifyOffset(verifier, VT_DATA_TYPE) &&
           verifier.VerifyString(data_type()) &&
           VerifyField<uint8_t>(verifier, VT_LOCKED) &&
           VerifyOffset(verifier, VT_RECIPIENT) &&
           verifier.VerifyVector(recipient()) &&
           VerifyOffset(verifier, VT_OWNER) &&
           verifier.VerifyVector(owner()) &&
           VerifyField<uint32_t>(verifier, VT_FILE_SIZE) &&
           VerifyOffset(verifier, VT_ENC_DATA) &&
           verifier.VerifyVector(enc_data()) &&
           VerifyOffset(verifier, VT_CHECKSUM) &&
           verifier.VerifyVector(checksum()) &&
           verifier.EndTable();
  }
};

struct IpfsDataBuilder {
  typedef IpfsData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> key) {
    fbb_.AddOffset(IpfsData::VT_KEY, key);
  }
  void add_enc_type(flatbuffers::Offset<flatbuffers::String> enc_type) {
    fbb_.AddOffset(IpfsData::VT_ENC_TYPE, enc_type);
  }
  void add_data_type(flatbuffers::Offset<flatbuffers::String> data_type) {
    fbb_.AddOffset(IpfsData::VT_DATA_TYPE, data_type);
  }
  void add_locked(bool locked) {
    fbb_.AddElement<uint8_t>(IpfsData::VT_LOCKED, static_cast<uint8_t>(locked), 0);
  }
  void add_recipient(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> recipient) {
    fbb_.AddOffset(IpfsData::VT_RECIPIENT, recipient);
  }
  void add_owner(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> owner) {
    fbb_.AddOffset(IpfsData::VT_OWNER, owner);
  }
  void add_file_size(uint32_t file_size) {
    fbb_.AddElement<uint32_t>(IpfsData::VT_FILE_SIZE, file_size, 0);
  }
  void add_enc_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> enc_data) {
    fbb_.AddOffset(IpfsData::VT_ENC_DATA, enc_data);
  }
  void add_checksum(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> checksum) {
    fbb_.AddOffset(IpfsData::VT_CHECKSUM, checksum);
  }
  explicit IpfsDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<IpfsData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IpfsData>(end);
    return o;
  }
};

inline flatbuffers::Offset<IpfsData> CreateIpfsData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> key = 0,
    flatbuffers::Offset<flatbuffers::String> enc_type = 0,
    flatbuffers::Offset<flatbuffers::String> data_type = 0,
    bool locked = false,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> recipient = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> owner = 0,
    uint32_t file_size = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> enc_data = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> checksum = 0) {
  IpfsDataBuilder builder_(_fbb);
  builder_.add_checksum(checksum);
  builder_.add_enc_data(enc_data);
  builder_.add_file_size(file_size);
  builder_.add_owner(owner);
  builder_.add_recipient(recipient);
  builder_.add_data_type(data_type);
  builder_.add_enc_type(enc_type);
  builder_.add_key(key);
  builder_.add_locked(locked);
  return builder_.Finish();
}

inline flatbuffers::Offset<IpfsData> CreateIpfsDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *key = nullptr,
    const char *enc_type = nullptr,
    const char *data_type = nullptr,
    bool locked = false,
    const std::vector<uint8_t> *recipient = nullptr,
    const std::vector<uint8_t> *owner = nullptr,
    uint32_t file_size = 0,
    const std::vector<uint8_t> *enc_data = nullptr,
    const std::vector<uint8_t> *checksum = nullptr) {
  auto key__ = key ? _fbb.CreateVector<uint8_t>(*key) : 0;
  auto enc_type__ = enc_type ? _fbb.CreateString(enc_type) : 0;
  auto data_type__ = data_type ? _fbb.CreateString(data_type) : 0;
  auto recipient__ = recipient ? _fbb.CreateVector<uint8_t>(*recipient) : 0;
  auto owner__ = owner ? _fbb.CreateVector<uint8_t>(*owner) : 0;
  auto enc_data__ = enc_data ? _fbb.CreateVector<uint8_t>(*enc_data) : 0;
  auto checksum__ = checksum ? _fbb.CreateVector<uint8_t>(*checksum) : 0;
  return SmartDoge::CreateIpfsData(
      _fbb,
      key__,
      enc_type__,
      data_type__,
      locked,
      recipient__,
      owner__,
      file_size,
      enc_data__,
      checksum__);
}

struct FileKey FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FileKeyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_V = 4,
    VT_EK = 6
  };
  const flatbuffers::Vector<uint8_t> *v() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_V);
  }
  const flatbuffers::Vector<uint8_t> *ek() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_EK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_V) &&
           verifier.VerifyVector(v()) &&
           VerifyOffset(verifier, VT_EK) &&
           verifier.VerifyVector(ek()) &&
           verifier.EndTable();
  }
};

struct FileKeyBuilder {
  typedef FileKey Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_v(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> v) {
    fbb_.AddOffset(FileKey::VT_V, v);
  }
  void add_ek(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> ek) {
    fbb_.AddOffset(FileKey::VT_EK, ek);
  }
  explicit FileKeyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FileKey> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FileKey>(end);
    return o;
  }
};

inline flatbuffers::Offset<FileKey> CreateFileKey(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> v = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> ek = 0) {
  FileKeyBuilder builder_(_fbb);
  builder_.add_ek(ek);
  builder_.add_v(v);
  return builder_.Finish();
}

inline flatbuffers::Offset<FileKey> CreateFileKeyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *v = nullptr,
    const std::vector<uint8_t> *ek = nullptr) {
  auto v__ = v ? _fbb.CreateVector<uint8_t>(*v) : 0;
  auto ek__ = ek ? _fbb.CreateVector<uint8_t>(*ek) : 0;
  return SmartDoge::CreateFileKey(
      _fbb,
      v__,
      ek__);
}

struct StoreResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StoreResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERR = 4,
    VT_CODE = 6,
    VT_FILE_KEY = 8
  };
  const flatbuffers::Vector<uint8_t> *err() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ERR);
  }
  uint32_t code() const {
    return GetField<uint32_t>(VT_CODE, 0);
  }
  const flatbuffers::Vector<uint8_t> *file_key() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_FILE_KEY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ERR) &&
           verifier.VerifyVector(err()) &&
           VerifyField<uint32_t>(verifier, VT_CODE) &&
           VerifyOffset(verifier, VT_FILE_KEY) &&
           verifier.VerifyVector(file_key()) &&
           verifier.EndTable();
  }
};

struct StoreResponseBuilder {
  typedef StoreResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_err(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> err) {
    fbb_.AddOffset(StoreResponse::VT_ERR, err);
  }
  void add_code(uint32_t code) {
    fbb_.AddElement<uint32_t>(StoreResponse::VT_CODE, code, 0);
  }
  void add_file_key(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> file_key) {
    fbb_.AddOffset(StoreResponse::VT_FILE_KEY, file_key);
  }
  explicit StoreResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StoreResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StoreResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<StoreResponse> CreateStoreResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> err = 0,
    uint32_t code = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> file_key = 0) {
  StoreResponseBuilder builder_(_fbb);
  builder_.add_file_key(file_key);
  builder_.add_code(code);
  builder_.add_err(err);
  return builder_.Finish();
}

inline flatbuffers::Offset<StoreResponse> CreateStoreResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *err = nullptr,
    uint32_t code = 0,
    const std::vector<uint8_t> *file_key = nullptr) {
  auto err__ = err ? _fbb.CreateVector<uint8_t>(*err) : 0;
  auto file_key__ = file_key ? _fbb.CreateVector<uint8_t>(*file_key) : 0;
  return SmartDoge::CreateStoreResponse(
      _fbb,
      err__,
      code,
      file_key__);
}

struct RetrieveResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RetrieveResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERR = 4,
    VT_CODE = 6,
    VT_FILE_KEY = 8,
    VT_FILEDATA = 10
  };
  const flatbuffers::Vector<uint8_t> *err() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ERR);
  }
  uint32_t code() const {
    return GetField<uint32_t>(VT_CODE, 0);
  }
  const flatbuffers::Vector<uint8_t> *file_key() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_FILE_KEY);
  }
  const flatbuffers::Vector<uint8_t> *filedata() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_FILEDATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ERR) &&
           verifier.VerifyVector(err()) &&
           VerifyField<uint32_t>(verifier, VT_CODE) &&
           VerifyOffset(verifier, VT_FILE_KEY) &&
           verifier.VerifyVector(file_key()) &&
           VerifyOffset(verifier, VT_FILEDATA) &&
           verifier.VerifyVector(filedata()) &&
           verifier.EndTable();
  }
};

struct RetrieveResponseBuilder {
  typedef RetrieveResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_err(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> err) {
    fbb_.AddOffset(RetrieveResponse::VT_ERR, err);
  }
  void add_code(uint32_t code) {
    fbb_.AddElement<uint32_t>(RetrieveResponse::VT_CODE, code, 0);
  }
  void add_file_key(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> file_key) {
    fbb_.AddOffset(RetrieveResponse::VT_FILE_KEY, file_key);
  }
  void add_filedata(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> filedata) {
    fbb_.AddOffset(RetrieveResponse::VT_FILEDATA, filedata);
  }
  explicit RetrieveResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RetrieveResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RetrieveResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<RetrieveResponse> CreateRetrieveResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> err = 0,
    uint32_t code = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> file_key = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> filedata = 0) {
  RetrieveResponseBuilder builder_(_fbb);
  builder_.add_filedata(filedata);
  builder_.add_file_key(file_key);
  builder_.add_code(code);
  builder_.add_err(err);
  return builder_.Finish();
}

inline flatbuffers::Offset<RetrieveResponse> CreateRetrieveResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *err = nullptr,
    uint32_t code = 0,
    const std::vector<uint8_t> *file_key = nullptr,
    const std::vector<uint8_t> *filedata = nullptr) {
  auto err__ = err ? _fbb.CreateVector<uint8_t>(*err) : 0;
  auto file_key__ = file_key ? _fbb.CreateVector<uint8_t>(*file_key) : 0;
  auto filedata__ = filedata ? _fbb.CreateVector<uint8_t>(*filedata) : 0;
  return SmartDoge::CreateRetrieveResponse(
      _fbb,
      err__,
      code,
      file_key__,
      filedata__);
}

struct ContractRawData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ContractRawDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EMOJI_SET = 4,
    VT_CONTEXT = 6,
    VT_OWNER_ADDRESS = 8,
    VT_RAW_DATA = 10
  };
  const flatbuffers::Vector<uint8_t> *emoji_set() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_EMOJI_SET);
  }
  const flatbuffers::Vector<uint8_t> *context() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CONTEXT);
  }
  const flatbuffers::Vector<uint8_t> *owner_address() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_OWNER_ADDRESS);
  }
  const flatbuffers::Vector<uint8_t> *raw_data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_RAW_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_EMOJI_SET) &&
           verifier.VerifyVector(emoji_set()) &&
           VerifyOffset(verifier, VT_CONTEXT) &&
           verifier.VerifyVector(context()) &&
           VerifyOffset(verifier, VT_OWNER_ADDRESS) &&
           verifier.VerifyVector(owner_address()) &&
           VerifyOffset(verifier, VT_RAW_DATA) &&
           verifier.VerifyVector(raw_data()) &&
           verifier.EndTable();
  }
};

struct ContractRawDataBuilder {
  typedef ContractRawData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_emoji_set(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> emoji_set) {
    fbb_.AddOffset(ContractRawData::VT_EMOJI_SET, emoji_set);
  }
  void add_context(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> context) {
    fbb_.AddOffset(ContractRawData::VT_CONTEXT, context);
  }
  void add_owner_address(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> owner_address) {
    fbb_.AddOffset(ContractRawData::VT_OWNER_ADDRESS, owner_address);
  }
  void add_raw_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> raw_data) {
    fbb_.AddOffset(ContractRawData::VT_RAW_DATA, raw_data);
  }
  explicit ContractRawDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ContractRawData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ContractRawData>(end);
    return o;
  }
};

inline flatbuffers::Offset<ContractRawData> CreateContractRawData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> emoji_set = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> context = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> owner_address = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> raw_data = 0) {
  ContractRawDataBuilder builder_(_fbb);
  builder_.add_raw_data(raw_data);
  builder_.add_owner_address(owner_address);
  builder_.add_context(context);
  builder_.add_emoji_set(emoji_set);
  return builder_.Finish();
}

inline flatbuffers::Offset<ContractRawData> CreateContractRawDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *emoji_set = nullptr,
    const std::vector<uint8_t> *context = nullptr,
    const std::vector<uint8_t> *owner_address = nullptr,
    const std::vector<uint8_t> *raw_data = nullptr) {
  auto emoji_set__ = emoji_set ? _fbb.CreateVector<uint8_t>(*emoji_set) : 0;
  auto context__ = context ? _fbb.CreateVector<uint8_t>(*context) : 0;
  auto owner_address__ = owner_address ? _fbb.CreateVector<uint8_t>(*owner_address) : 0;
  auto raw_data__ = raw_data ? _fbb.CreateVector<uint8_t>(*raw_data) : 0;
  return SmartDoge::CreateContractRawData(
      _fbb,
      emoji_set__,
      context__,
      owner_address__,
      raw_data__);
}

struct StoreContractResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StoreContractResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERR = 4,
    VT_CODE = 6,
    VT_RESULT = 8,
    VT_EMOJI_STRING = 10,
    VT_TX_HASH = 12
  };
  const flatbuffers::Vector<uint8_t> *err() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ERR);
  }
  uint32_t code() const {
    return GetField<uint32_t>(VT_CODE, 0);
  }
  const flatbuffers::Vector<uint8_t> *result() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_RESULT);
  }
  const flatbuffers::String *emoji_string() const {
    return GetPointer<const flatbuffers::String *>(VT_EMOJI_STRING);
  }
  const flatbuffers::Vector<uint8_t> *tx_hash() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_TX_HASH);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ERR) &&
           verifier.VerifyVector(err()) &&
           VerifyField<uint32_t>(verifier, VT_CODE) &&
           VerifyOffset(verifier, VT_RESULT) &&
           verifier.VerifyVector(result()) &&
           VerifyOffset(verifier, VT_EMOJI_STRING) &&
           verifier.VerifyString(emoji_string()) &&
           VerifyOffset(verifier, VT_TX_HASH) &&
           verifier.VerifyVector(tx_hash()) &&
           verifier.EndTable();
  }
};

struct StoreContractResponseBuilder {
  typedef StoreContractResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_err(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> err) {
    fbb_.AddOffset(StoreContractResponse::VT_ERR, err);
  }
  void add_code(uint32_t code) {
    fbb_.AddElement<uint32_t>(StoreContractResponse::VT_CODE, code, 0);
  }
  void add_result(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> result) {
    fbb_.AddOffset(StoreContractResponse::VT_RESULT, result);
  }
  void add_emoji_string(flatbuffers::Offset<flatbuffers::String> emoji_string) {
    fbb_.AddOffset(StoreContractResponse::VT_EMOJI_STRING, emoji_string);
  }
  void add_tx_hash(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> tx_hash) {
    fbb_.AddOffset(StoreContractResponse::VT_TX_HASH, tx_hash);
  }
  explicit StoreContractResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StoreContractResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StoreContractResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<StoreContractResponse> CreateStoreContractResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> err = 0,
    uint32_t code = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> result = 0,
    flatbuffers::Offset<flatbuffers::String> emoji_string = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> tx_hash = 0) {
  StoreContractResponseBuilder builder_(_fbb);
  builder_.add_tx_hash(tx_hash);
  builder_.add_emoji_string(emoji_string);
  builder_.add_result(result);
  builder_.add_code(code);
  builder_.add_err(err);
  return builder_.Finish();
}

inline flatbuffers::Offset<StoreContractResponse> CreateStoreContractResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *err = nullptr,
    uint32_t code = 0,
    const std::vector<uint8_t> *result = nullptr,
    const char *emoji_string = nullptr,
    const std::vector<uint8_t> *tx_hash = nullptr) {
  auto err__ = err ? _fbb.CreateVector<uint8_t>(*err) : 0;
  auto result__ = result ? _fbb.CreateVector<uint8_t>(*result) : 0;
  auto emoji_string__ = emoji_string ? _fbb.CreateString(emoji_string) : 0;
  auto tx_hash__ = tx_hash ? _fbb.CreateVector<uint8_t>(*tx_hash) : 0;
  return SmartDoge::CreateStoreContractResponse(
      _fbb,
      err__,
      code,
      result__,
      emoji_string__,
      tx_hash__);
}

struct ContractRequestResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ContractRequestResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERR = 4,
    VT_CODE = 6,
    VT_RESULT = 8
  };
  const flatbuffers::Vector<uint8_t> *err() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ERR);
  }
  uint32_t code() const {
    return GetField<uint32_t>(VT_CODE, 0);
  }
  const flatbuffers::Vector<uint8_t> *result() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_RESULT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ERR) &&
           verifier.VerifyVector(err()) &&
           VerifyField<uint32_t>(verifier, VT_CODE) &&
           VerifyOffset(verifier, VT_RESULT) &&
           verifier.VerifyVector(result()) &&
           verifier.EndTable();
  }
};

struct ContractRequestResponseBuilder {
  typedef ContractRequestResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_err(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> err) {
    fbb_.AddOffset(ContractRequestResponse::VT_ERR, err);
  }
  void add_code(uint32_t code) {
    fbb_.AddElement<uint32_t>(ContractRequestResponse::VT_CODE, code, 0);
  }
  void add_result(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> result) {
    fbb_.AddOffset(ContractRequestResponse::VT_RESULT, result);
  }
  explicit ContractRequestResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ContractRequestResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ContractRequestResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<ContractRequestResponse> CreateContractRequestResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> err = 0,
    uint32_t code = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> result = 0) {
  ContractRequestResponseBuilder builder_(_fbb);
  builder_.add_result(result);
  builder_.add_code(code);
  builder_.add_err(err);
  return builder_.Finish();
}

inline flatbuffers::Offset<ContractRequestResponse> CreateContractRequestResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *err = nullptr,
    uint32_t code = 0,
    const std::vector<uint8_t> *result = nullptr) {
  auto err__ = err ? _fbb.CreateVector<uint8_t>(*err) : 0;
  auto result__ = result ? _fbb.CreateVector<uint8_t>(*result) : 0;
  return SmartDoge::CreateContractRequestResponse(
      _fbb,
      err__,
      code,
      result__);
}

struct ContractRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ContractRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FROM_ADDRESS = 4,
    VT_CONTRACT_ADDRESS = 6
  };
  const flatbuffers::Vector<uint8_t> *from_address() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_FROM_ADDRESS);
  }
  const flatbuffers::Vector<uint8_t> *contract_address() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CONTRACT_ADDRESS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FROM_ADDRESS) &&
           verifier.VerifyVector(from_address()) &&
           VerifyOffset(verifier, VT_CONTRACT_ADDRESS) &&
           verifier.VerifyVector(contract_address()) &&
           verifier.EndTable();
  }
};

struct ContractRequestBuilder {
  typedef ContractRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_from_address(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> from_address) {
    fbb_.AddOffset(ContractRequest::VT_FROM_ADDRESS, from_address);
  }
  void add_contract_address(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> contract_address) {
    fbb_.AddOffset(ContractRequest::VT_CONTRACT_ADDRESS, contract_address);
  }
  explicit ContractRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ContractRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ContractRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ContractRequest> CreateContractRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> from_address = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> contract_address = 0) {
  ContractRequestBuilder builder_(_fbb);
  builder_.add_contract_address(contract_address);
  builder_.add_from_address(from_address);
  return builder_.Finish();
}

inline flatbuffers::Offset<ContractRequest> CreateContractRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *from_address = nullptr,
    const std::vector<uint8_t> *contract_address = nullptr) {
  auto from_address__ = from_address ? _fbb.CreateVector<uint8_t>(*from_address) : 0;
  auto contract_address__ = contract_address ? _fbb.CreateVector<uint8_t>(*contract_address) : 0;
  return SmartDoge::CreateContractRequest(
      _fbb,
      from_address__,
      contract_address__);
}

inline const SmartDoge::RawProtocol *GetRawProtocol(const void *buf) {
  return flatbuffers::GetRoot<SmartDoge::RawProtocol>(buf);
}

inline const SmartDoge::RawProtocol *GetSizePrefixedRawProtocol(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<SmartDoge::RawProtocol>(buf);
}

inline bool VerifyRawProtocolBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<SmartDoge::RawProtocol>(nullptr);
}

inline bool VerifySizePrefixedRawProtocolBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<SmartDoge::RawProtocol>(nullptr);
}

inline void FinishRawProtocolBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<SmartDoge::RawProtocol> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedRawProtocolBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<SmartDoge::RawProtocol> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace SmartDoge

#endif  // FLATBUFFERS_GENERATED_SMARTDOGE_SMARTDOGE_H_
